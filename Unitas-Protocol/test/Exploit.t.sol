// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol";
import "forge-std/Test.sol";
import "../src/interfaces/ISwapFunctions.sol";
import "../src/interfaces/IERC20Token.sol";
import "../src/interfaces/IInsurancePool.sol";
import "../src/interfaces/IOracle.sol";
import "../src/interfaces/IUnitas.sol";
import "../src/utils/Errors.sol";
import "../src/utils/ScalingUtils.sol";
import "../src/ERC20Token.sol";
import "../src/InsurancePool.sol";
import "../src/TokenManager.sol";
import "../src/Unitas.sol";
import "../src/UnitasProxy.sol";
import "../src/UnitasProxyAdmin.sol";
import "../src/XOracle.sol";
import "./mocks/MockERC20Token.sol";
import "./utils/Functions.sol";

contract ExploitTest is Test {
    using MathUpgradeable for uint256;
    using SafeCastUpgradeable for uint256;

    struct SwapData {
        address account;
        address tokenIn;
        address tokenOut;
        ISwapFunctions.AmountType amountType;
        uint256 amountIn;
        uint256 amountOut;
        uint256 fee;
        uint24 feeNumerator;
        uint256 price;
        uint256 approxPrice;
    }

    IERC20Token internal _usd1;
    IERC20Token internal _usd91;
    IERC20Token internal _usd971;
    XOracle internal _oracle;
    MockERC20Token internal _usdt;
    InsurancePool internal _insurancePool;
    UnitasProxyAdmin internal _proxyAdmin;
    TokenManager internal _tokenManager;

    UnitasHarness internal _unitas;
    UnitasProxy internal _unitasProxy;
    UnitasHarness internal _unitasLogic;
    UnitasHarnessV2 internal _unitasLogicV2;
 
    address internal immutable _governor = vm.addr(0x1);
    address internal immutable _guardian = vm.addr(0x2);
    address internal immutable _timelock = vm.addr(0x3);
    address internal immutable _surplusPool = vm.addr(0x4);
    address internal immutable _proxyAdminOwner = vm.addr(0x5);

    event SetOracle(address indexed newOracle);
    event SetSurplusPool(address indexed newSurplusPool);
    event SetInsurancePool(address indexed newInsurancePool);
    event SetTokenManager(address indexed newTokenManager);
    event Swapped(
        address indexed tokenIn,
        address indexed tokenOut,
        address indexed sender,
        uint256 amountIn,
        uint256 amountOut,
        address feeToken,
        uint256 fee,
        uint24 feeNumerator,
        uint256 price
    );
    event SwapFeeSent(address indexed feeToken, address indexed receiver, uint256 fee);
    event BalanceUpdated(address indexed token, uint256 newBalance);

    function setUp() public virtual {
        _deployContracts();
        _initLabels();

        // 1:1
        _updatePrice(address(_usdt), 1e18);
        _usdt.approve(address(_unitas), type(uint256).max);

        bytes32 minterRole = _usd1.MINTER_ROLE();

        vm.startPrank(_governor);
        _usd1.setMinter(address(_unitas), _governor);
        _usd91.setMinter(address(_unitas), _governor);
        _usd971.setMinter(address(_unitas), _governor);
        AccessControl(address(_usd1)).grantRole(minterRole, address(this));
        AccessControl(address(_usd91)).grantRole(minterRole, address(this));
        AccessControl(address(_usd971)).grantRole(minterRole, address(this));
        vm.stopPrank();

        bytes32 withdrawerRole = _insurancePool.WITHDRAWER_ROLE();

        vm.startPrank(_guardian);
        _insurancePool.grantRole(withdrawerRole, address(_unitas));
        vm.stopPrank();
    }

    // @audit-info when token reserve (IP pool) amount is has equal to amountOut
    function test_scenario_1() public {

        uint256 amountIn = 2e6;
        uint256 amountOut = 2e18;
        uint256 fee = 0;

        // Adds collateral to pass the reserve ratio checking
        // adds amount in _balance storage variable
        _addCollateral(address(_usdt), ScalingUtils.scaleByDecimals(1000e18, 18, _usdt.decimals()));
        
        deal(address(_usdt), address(this), amountIn);

        address user = address(this);
        address unitas = address(_unitas);
        uint256 userUSDT = _usdt.balanceOf(user);
        uint256 userUSD1 = _usd1.balanceOf(user);
        uint256 unitasUSDT = _usdt.balanceOf(unitas);
        uint256 surplusPoolUSD1 = _usd1.balanceOf(_surplusPool);

        /*
            @audit-info
            tokenIn = usdt
            tokenOut= usd1
            amountType = In
            amountIn = 2e6
            
            fee ratio                        : 0
            price                            : 1
            spend                            : 1 USDT
            obtain                           : 1 USD1
            fee                              : 0 USD1
        */
        _unitas.swap(address(_usdt), address(_usd1), ISwapFunctions.AmountType.In, amountIn);

        assertEq(_usdt.balanceOf(user), userUSDT - amountIn, "user usdt balance after minted");
        assertEq(_usd1.balanceOf(user), userUSD1 + amountOut, "user usd1 balance after minted");
        assertEq(_usdt.balanceOf(unitas), unitasUSDT + amountIn, "unitas usdt balance after minted");
        assertEq(_usd1.balanceOf(_surplusPool), surplusPoolUSD1 + fee, "surplus pool usd1 balance after minted");
        
        console.log("\n ------------------------------- \n");

        userUSDT = _usdt.balanceOf(user);
        userUSD1 = _usd1.balanceOf(user);
        unitasUSDT = _usdt.balanceOf(unitas);
        surplusPoolUSD1 = _usd1.balanceOf(_surplusPool);
        amountIn = 2e18;
        amountOut = 2e6;
        fee = 0;
        
        /*
            @audit-info
            tokenIn = usd1
            tokenOut= usdt
            amountType = In
            amountIn = 1e18

            // fee ratio                        : 0
            // price                            : 1
            // spend                            : 1 USD1
            // obtain                           : 1 USDT
            // fee                              : 0 USD1
        */
        _unitas.swap(address(_usd1), address(_usdt), ISwapFunctions.AmountType.In, amountIn);

        assertEq(_usdt.balanceOf(user), userUSDT + amountOut, "user usdt balance after redeemed");
        assertEq(_usd1.balanceOf(user), userUSD1 - amountIn, "user usd1 balance after redeemed");
        assertEq(_usdt.balanceOf(unitas), unitasUSDT - amountOut, "unitas usdt balance after redeemed");
        assertEq(_usd1.balanceOf(_surplusPool), surplusPoolUSD1 + fee, "surplus pool usd1 balance after redeemed");
    }

    // @audit-info when token reserve (IP pool) amount is greater than amountOut
    function test_scenario_2() public {

        uint256 amountIn = 4e6;
        uint256 amountOut = 4e18;
        uint256 fee = 0;

        // Adds collateral to pass the reserve ratio checking
        // adds amount in _balance storage variable
        _addCollateral(address(_usdt), ScalingUtils.scaleByDecimals(1000e18, 18, _usdt.decimals()));
        
        deal(address(_usdt), address(this), amountIn);

        address user = address(this);
        address unitas = address(_unitas);
        uint256 userUSDT = _usdt.balanceOf(user);
        uint256 userUSD1 = _usd1.balanceOf(user);
        uint256 unitasUSDT = _usdt.balanceOf(unitas);
        uint256 surplusPoolUSD1 = _usd1.balanceOf(_surplusPool);

        /*
            @audit-info
            tokenIn = usdt
            tokenOut= usd1
            amountType = In
            amountIn = 2e6
            
            fee ratio                        : 0
            price                            : 1
            spend                            : 1 USDT
            obtain                           : 1 USD1
            fee                              : 0 USD1
        */
        _unitas.swap(address(_usdt), address(_usd1), ISwapFunctions.AmountType.In, amountIn);

        assertEq(_usdt.balanceOf(user), userUSDT - amountIn, "user usdt balance after minted");
        assertEq(_usd1.balanceOf(user), userUSD1 + amountOut, "user usd1 balance after minted");
        assertEq(_usdt.balanceOf(unitas), unitasUSDT + amountIn, "unitas usdt balance after minted");
        assertEq(_usd1.balanceOf(_surplusPool), surplusPoolUSD1 + fee, "surplus pool usd1 balance after minted");
        
        console.log("\n ------------------------------- \n");

        userUSDT = _usdt.balanceOf(user);
        userUSD1 = _usd1.balanceOf(user);
        unitasUSDT = _usdt.balanceOf(unitas);
        surplusPoolUSD1 = _usd1.balanceOf(_surplusPool);
        amountIn = 2e18;
        amountOut = 2e6;
        fee = 0;
        
        /*
            @audit-info
            tokenIn = usd1
            tokenOut= usdt
            amountType = In
            amountIn = 1e18

            // fee ratio                        : 0
            // price                            : 1
            // spend                            : 1 USD1
            // obtain                           : 1 USDT
            // fee                              : 0 USD1
        */


        _unitas.swap(address(_usd1), address(_usdt), ISwapFunctions.AmountType.In, amountIn);

        assertEq(_usdt.balanceOf(user), userUSDT + amountOut, "user usdt balance after redeemed");
        assertEq(_usd1.balanceOf(user), userUSD1 - amountIn, "user usd1 balance after redeemed");
        assertEq(_usdt.balanceOf(unitas), unitasUSDT - amountOut, "unitas usdt balance after redeemed");
        assertEq(_usd1.balanceOf(_surplusPool), surplusPoolUSD1 + fee, "surplus pool usd1 balance after redeemed");
    }

    // @audit-info when token reserve (IP pool) + Insurance Pool amount is less than amountOut
    function test_scenario_3() public {

        uint256 amountIn = 4e6;
        uint256 amountOut = 4e18;
        uint256 fee = 0;

        // Adds collateral to pass the reserve ratio checking
        // adds amount in _balance storage variable
        _addCollateral(address(_usdt), ScalingUtils.scaleByDecimals(2e18, 18, _usdt.decimals()));

        deal(address(_usdt), address(this), amountIn);

        address user = address(this);
        address unitas = address(_unitas);
        uint256 userUSDT = _usdt.balanceOf(user);
        uint256 userUSD1 = _usd1.balanceOf(user);
        uint256 unitasUSDT = _usdt.balanceOf(unitas);
        uint256 surplusPoolUSD1 = _usd1.balanceOf(_surplusPool);

        /*
            @audit-info
            tokenIn = usdt
            tokenOut= usd1
            amountType = In
            amountIn = 2e6
            
            fee ratio                        : 0
            price                            : 1
            spend                            : 1 USDT
            obtain                           : 1 USD1
            fee                              : 0 USD1
        */
        _unitas.swap(address(_usdt), address(_usd1), ISwapFunctions.AmountType.In, amountIn);

        assertEq(_usdt.balanceOf(user), userUSDT - amountIn, "user usdt balance after minted");
        assertEq(_usd1.balanceOf(user), userUSD1 + amountOut, "user usd1 balance after minted");
        assertEq(_usdt.balanceOf(unitas), unitasUSDT + amountIn, "unitas usdt balance after minted");
        assertEq(_usd1.balanceOf(_surplusPool), surplusPoolUSD1 + fee, "surplus pool usd1 balance after minted");
        
        console.log("\n ------------------------------- \n");

        userUSDT = _usdt.balanceOf(user);
        userUSD1 = _usd1.balanceOf(user);
        unitasUSDT = _usdt.balanceOf(unitas);
        surplusPoolUSD1 = _usd1.balanceOf(_surplusPool);
        amountIn = 8e18;
        amountOut = 8e6;
        fee = 0;

        // @audit add more usd1 
        console.log('userUSD1 balance before mint ', _usd1.balanceOf(user));
        _usd1.mint(address(this), 4e18);
        console.log('userUSD1 balance after mint ', _usd1.balanceOf(user));    
        
        /*
            @audit-info
            tokenIn = usd1
            tokenOut= usdt
            amountType = In
            amountIn = 1e18

            // fee ratio                        : 0
            // price                            : 1
            // spend                            : 1 USD1
            // obtain                           : 1 USDT
            // fee                              : 0 USD1
        */
        _unitas.swap(address(_usd1), address(_usdt), ISwapFunctions.AmountType.In, amountIn);

        assertEq(_usdt.balanceOf(user), userUSDT + amountOut, "user usdt balance after redeemed");
        assertEq(_usd1.balanceOf(user), userUSD1 - amountIn, "user usd1 balance after redeemed");
        assertEq(_usdt.balanceOf(unitas), unitasUSDT - amountOut, "unitas usdt balance after redeemed");
        assertEq(_usd1.balanceOf(_surplusPool), surplusPoolUSD1 + fee, "surplus pool usd1 balance after redeemed");
    }

    // @audit-info when token reserve (IP pool) + Insurance Pool amount is equal amountOut
    function test_scenario_4() public {

        uint256 amountIn = 4e6;
        uint256 amountOut = 4e18;
        uint256 fee = 0;

        // Adds collateral to pass the reserve ratio checking
        // adds amount in _balance storage variable
        _addCollateral(address(_usdt), ScalingUtils.scaleByDecimals(4e18, 18, _usdt.decimals()));

        deal(address(_usdt), address(this), amountIn);

        address user = address(this);
        address unitas = address(_unitas);
        uint256 userUSDT = _usdt.balanceOf(user);
        uint256 userUSD1 = _usd1.balanceOf(user);
        uint256 unitasUSDT = _usdt.balanceOf(unitas);
        uint256 surplusPoolUSD1 = _usd1.balanceOf(_surplusPool);

        /*
            @audit-info
            tokenIn = usdt
            tokenOut= usd1
            amountType = In
            amountIn = 2e6
            
            fee ratio                        : 0
            price                            : 1
            spend                            : 1 USDT
            obtain                           : 1 USD1
            fee                              : 0 USD1
        */
        _unitas.swap(address(_usdt), address(_usd1), ISwapFunctions.AmountType.In, amountIn);

        assertEq(_usdt.balanceOf(user), userUSDT - amountIn, "user usdt balance after minted");
        assertEq(_usd1.balanceOf(user), userUSD1 + amountOut, "user usd1 balance after minted");
        assertEq(_usdt.balanceOf(unitas), unitasUSDT + amountIn, "unitas usdt balance after minted");
        assertEq(_usd1.balanceOf(_surplusPool), surplusPoolUSD1 + fee, "surplus pool usd1 balance after minted");
        
        console.log("\n ------------------------------- \n");

        userUSDT = _usdt.balanceOf(user);
        userUSD1 = _usd1.balanceOf(user);
        unitasUSDT = _usdt.balanceOf(unitas);
        surplusPoolUSD1 = _usd1.balanceOf(_surplusPool);
        amountIn = 8e18;
        amountOut = 8e6;
        fee = 0;

        // @audit add more usd1 
        console.log('userUSD1 balance before mint ', _usd1.balanceOf(user));
        _usd1.mint(address(this), 4e18);
        console.log('userUSD1 balance after mint ', _usd1.balanceOf(user));    
        
        /*
            @audit-info
            tokenIn = usd1
            tokenOut= usdt
            amountType = In
            amountIn = 1e18

            // fee ratio                        : 0
            // price                            : 1
            // spend                            : 1 USD1
            // obtain                           : 1 USDT
            // fee                              : 0 USD1
        */
        _unitas.swap(address(_usd1), address(_usdt), ISwapFunctions.AmountType.In, amountIn);

        assertEq(_usdt.balanceOf(user), 8e6, "user usdt balance after redeemed");
        assertEq(_usd1.balanceOf(user), 0, "user usd1 balance after redeemed");
        assertEq(_usdt.balanceOf(unitas), 0, "unitas usdt balance after redeemed");
        assertEq(_usd1.balanceOf(_surplusPool), surplusPoolUSD1 + fee, "surplus pool usd1 balance after redeemed");
    }

    // @audit-info when token reserve (IP pool) + Insurance Pool amount is equal amountOut
    function test_scenario_4_1() public {

        uint256 amountIn = 2e6;
        uint256 amountOut = 2e18;
        uint256 fee = 0;

        // Adds collateral to pass the reserve ratio checking
        // adds amount in _balance storage variable
        _addCollateral(address(_usdt), ScalingUtils.scaleByDecimals(6e18, 18, _usdt.decimals()));

        deal(address(_usdt), address(this), 8e18);

        address user = address(this);
        address unitas = address(_unitas);
        uint256 userUSDT = _usdt.balanceOf(user);
        uint256 userUSD1 = _usd1.balanceOf(user);
        uint256 unitasUSDT = _usdt.balanceOf(unitas);
        uint256 surplusPoolUSD1 = _usd1.balanceOf(_surplusPool);

        /*
            @audit-info
            tokenIn = usdt
            tokenOut= usd1
            amountType = In
            amountIn = 2e6
            
            fee ratio                        : 0
            price                            : 1
            spend                            : 1 USDT
            obtain                           : 1 USD1
            fee                              : 0 USD1
        */
        _unitas.swap(address(_usdt), address(_usd1), ISwapFunctions.AmountType.In, amountIn);

        assertEq(_usdt.balanceOf(user), userUSDT - amountIn, "user usdt balance after minted");
        assertEq(_usd1.balanceOf(user), userUSD1 + amountOut, "user usd1 balance after minted");
        assertEq(_usdt.balanceOf(unitas), unitasUSDT + amountIn, "unitas usdt balance after minted");
        assertEq(_usd1.balanceOf(_surplusPool), surplusPoolUSD1 + fee, "surplus pool usd1 balance after minted");
        
        console.log("\n ------------------------------- \n");

        userUSDT = _usdt.balanceOf(user);
        userUSD1 = _usd1.balanceOf(user);
        unitasUSDT = _usdt.balanceOf(unitas);
        surplusPoolUSD1 = _usd1.balanceOf(_surplusPool);
        amountIn = 8e18;
        amountOut = 8e6;
        fee = 0;

        // @audit add more usd1 
        console.log('userUSD1 balance before mint ', _usd1.balanceOf(user));
        _usd1.mint(address(this), 6e18);
        console.log('userUSD1 balance after mint ', _usd1.balanceOf(user));    
        
        /*
            @audit-info
            tokenIn = usd1
            tokenOut= usdt
            amountType = In
            amountIn = 1e18

            // fee ratio                        : 0
            // price                            : 1
            // spend                            : 1 USD1
            // obtain                           : 1 USDT
            // fee                              : 0 USD1
        */
        _unitas.swap(address(_usd1), address(_usdt), ISwapFunctions.AmountType.In, amountIn);

        assertEq(_usdt.balanceOf(user), 8e6, "user usdt balance after redeemed");
        assertEq(_usd1.balanceOf(user), 0, "user usd1 balance after redeemed");
        assertEq(_usdt.balanceOf(unitas), 0, "unitas usdt balance after redeemed");
        assertEq(_usd1.balanceOf(_surplusPool), surplusPoolUSD1 + fee, "surplus pool usd1 balance after redeemed");
    }

    function _updatePrice(address token, uint256 price) internal {
        (uint64 current_timestamp,,,) = _oracle.getPrice(token);
        _updatePrice(token, price, current_timestamp + 1);
    }

    function _updatePrice(address token, uint256 price, uint64 timestamp) internal {
        IOracle.NewPrice[] memory prices = new IOracle.NewPrice[](1);
        prices[0] = IOracle.NewPrice(token, timestamp, price);
        _oracle.updatePrices(prices);
    }

    function _addCollateral(address token, uint256 amount) internal {
        if (amount == 0) {
            return;
        }

        deal(token, _guardian, amount);

        vm.startPrank(_guardian);
        IERC20(token).approve(address(_insurancePool), amount);
        _insurancePool.depositCollateral(token, amount);
        vm.stopPrank();
    }

    function _getInitializeConfig() internal view returns (IUnitas.InitializeConfig memory config) {
        return IUnitas.InitializeConfig({
            governor: _governor,
            guardian: _guardian,
            timelock: _timelock,
            oracle: address(_oracle),
            surplusPool: _surplusPool,
            insurancePool: address(_insurancePool),
            tokenManager: _tokenManager
        });
    }

    function _deployContracts() internal {
        _proxyAdmin = new UnitasProxyAdmin(_proxyAdminOwner);

        _usd1 = _deployUnitasERC20Token("Unitas 1", "USD1");
        _usd91 = _deployUnitasERC20Token("Unitas 91", "USD91");
        _usd971 = _deployUnitasERC20Token("Unitas 971", "USD971");
        // Different decimals for testing conversions are correct
        _usdt = new MockERC20Token("Tether USD", "USDT", 6);
        _oracle = new XOracle();
        _insurancePool = new InsurancePool(_governor, _guardian, _timelock);
        _tokenManager = _deployTokenManager();

        IUnitas.InitializeConfig memory config = _getInitializeConfig();
        _unitasLogic = new UnitasHarness();
        _unitasProxy = new UnitasProxy(address(_unitasLogic), address(_proxyAdmin), config);
        _unitas = UnitasHarness(address(_unitasProxy));
    }

    function _deployUnitasERC20Token(string memory name, string memory symbol) internal returns (IERC20Token) {
        ERC20Token token = new ERC20Token(name, symbol, _governor, _guardian, _governor);
        return IERC20Token(address(token));
    }

    function _deployTokenManager() internal returns (TokenManager) {
        ITokenManager.TokenConfig[] memory tokens = new ITokenManager.TokenConfig[](3);
        tokens[0] = ITokenManager.TokenConfig({
            token: address(_usdt),
            tokenType: ITokenManager.TokenType.Asset,
            minPrice: 1,
            maxPrice: type(uint256).max
        });
        tokens[1] = ITokenManager.TokenConfig({
            token: address(_usd91),
            tokenType: ITokenManager.TokenType.Stable,
            minPrice: 1,
            maxPrice: type(uint256).max
        });
        tokens[2] = ITokenManager.TokenConfig({
            token: address(_usd971),
            tokenType: ITokenManager.TokenType.Stable,
            minPrice: 1,
            maxPrice: type(uint256).max
        });

        ITokenManager.PairConfig[] memory pairs = new ITokenManager.PairConfig[](3);
        pairs[0] = ITokenManager.PairConfig({
            baseToken: address(_usd1),
            quoteToken: address(_usdt),
            // USDT -> USD1 (mint)
            buyFee: 0,
            // 130%
            buyReserveRatioThreshold: 1.3e18,
            // USD1 -> USDT (redemption)
            sellFee: 0,
            // Unconditional exit
            sellReserveRatioThreshold: 0
        });
        pairs[1] = ITokenManager.PairConfig({
            baseToken: address(_usd1),
            quoteToken: address(_usd91),
            // USD91 -> USD1 (redemption)
            // 1%
            buyFee: 0.01e6,
            // Unconditional exit
            buyReserveRatioThreshold: 0,
            // USD1 -> USD91 (mint)
            // 1%
            sellFee: 0.01e6,
            // 100%
            sellReserveRatioThreshold: 1e18
        });
        pairs[2] = ITokenManager.PairConfig({
            baseToken: address(_usd1),
            quoteToken: address(_usd971),
            // USD971 -> USD1 (redemption)
            // 1%
            buyFee: 0.01e6,
            // Unconditional exit
            buyReserveRatioThreshold: 0,
            // USD1 -> USD971 (mint)
            // 1%
            sellFee: 0.01e6,
            // 100%
            sellReserveRatioThreshold: 1e18
        });

        return new TokenManager(_governor, _timelock, address(_usd1), tokens, pairs);
    }

    function _initLabels() internal {
        vm.label(address(_usd1), "USD1");
        vm.label(address(_usd91), "USD91");
        vm.label(address(_usd971), "USD971");
        vm.label(address(_usdt), "USDT");

        vm.label(address(_governor), "Governor");
        vm.label(address(_guardian), "Guardian");
        vm.label(address(_timelock), "Timelock");
        vm.label(address(_surplusPool), "SurplusPool");
    }
}

/**
 * @dev Tests `Unitas` with `UnitasProxy` and `ProxyAdmin` after upgrading logic contract to v2.
 */
contract UnitasProxyUpgradedTest is ExploitTest {
    function setUp() public virtual override {
        super.setUp();
    }
}

/**
 * @dev The harness contract inherits `Unitas` and exposes internal functions
 */
contract UnitasHarness is Unitas {
    constructor() {}
}

/**
 * @dev The parent contract to test upgrading logic contract with new composition
 */
contract UnitasHarnessV2NewParent {
    uint256 internal _parentValue;

    function parentValue() external view returns (uint256) {
        return _parentValue;
    }

    function setParentValue(uint256 newValue) external {
        _parentValue = newValue;
    }
}

/**
 * @dev The harness contract to test upgrading `UnitasHarness`.
 *      Storage layout sequence:
 *       Initializable, PausableUpgradeable, AccessControlUpgradeable, ReentrancyGuardUpgradeable,
 *       PoolBalances, Unitas, UnitasHarnessV2NewParent, UnitasHarnessV2.
 *      If we will inherit new contracts in the future,
 *      the disadvantage of this pattern is we need to declare functions as virtual which may be updated.
 *      If not, copy the old file and modify it will be simpler.
 */
contract UnitasHarnessV2 is UnitasHarness, UnitasHarnessV2NewParent {
    uint256 internal _value;
    uint256 internal _timelockValue;

    function setValue(uint256 newValue) external {
        _value = newValue;
    }

    function value() external view returns (uint256) {
        return _value;
    }

    function setTimelockValue(uint256 newValue) external onlyTimelock {
        _timelockValue = newValue;
    }

    function timelockValue() external view returns (uint256) {
        return _timelockValue;
    }

    function version() external pure returns (uint256) {
        return 2;
    }
}
